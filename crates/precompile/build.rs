#![allow(dead_code, unused_imports)]

use std::ffi::CString;
use std::fs;
use std::path::Path;
use std::slice;

const BYTES_PER_G1_POINT: usize = 48;
const BYTES_PER_G2_POINT: usize = 96;

fn main() {
    generate_kzg_settings();
}

fn generate_kzg_settings() {
    let in_path = "src/blob/kzg_settings/trusted_setup.txt";
    let out_path = "src/blob/kzg_settings/generated.rs";

    let in_path = Path::new(in_path);
    println!("cargo:rerun-if-changed={}", in_path.display());
    assert!(in_path.exists());
    let contents = format_kzg_settings_small(in_path);
    fs::write(out_path, contents).unwrap();
}

/// Pros:
/// - smaller generated file size (720K)
/// - smaller runtime static size (198K = `48*4096 + 96*65`)
/// - half the size of `trusted_setup.txt`, which would have to be included in the binary without
///   this build script
///
/// Cons:
/// - must call `load_trusted_setup` at least once
fn format_kzg_settings_small(in_path: &Path) -> String {
    let contents = fs::read_to_string(in_path).unwrap();
    let mut lines = contents.lines();

    // load number of points
    let n_g1 = lines.next().unwrap().parse::<usize>().unwrap();
    let n_g2 = lines.next().unwrap().parse::<usize>().unwrap();

    // TODO: We can use `hex_literal` to reduce file size
    // load g1 points
    let mut g1_points = Vec::with_capacity(n_g1);
    for _ in 0..n_g1 {
        let line = lines.next().unwrap();
        let mut bytes = [0; BYTES_PER_G1_POINT];
        hex::decode_to_slice(line, &mut bytes).unwrap();
        g1_points.push(bytes);
    }

    // load g2 points
    let mut g2_points = Vec::with_capacity(n_g2);
    for _ in 0..n_g2 {
        let line = lines.next().unwrap();
        let mut bytes = [0; BYTES_PER_G2_POINT];
        hex::decode_to_slice(line, &mut bytes).unwrap();
        g2_points.push(bytes);
    }

    // remove whitespace
    let g1_points = format!("{g1_points:?}").replace(' ', "");
    let g2_points = format!("{g2_points:?}").replace(' ', "");

    format!(
        r#"// @generated by build.rs from {in_path:?}, do not modify manually.

pub use c_kzg::{{BYTES_PER_G1_POINT, BYTES_PER_G2_POINT}};

// Ensure that the build script constants are synced with the C bindings ones.
const _: [(); BYTES_PER_G1_POINT] = [(); {BYTES_PER_G1_POINT}];
const _: [(); BYTES_PER_G2_POINT] = [(); {BYTES_PER_G2_POINT}];

pub const NUM_G1_POINTS: usize = {n_g1};
pub const NUM_G2_POINTS: usize = {n_g2};

pub const G1_POINTS: &[[u8; BYTES_PER_G1_POINT]; NUM_G1_POINTS] = &{g1_points};
pub const G2_POINTS: &[[u8; BYTES_PER_G2_POINT]; NUM_G2_POINTS] = &{g2_points};
"#
    )
}

/*
/// Pros:
/// - no need to call `load_trusted_setup` at runtime
///
/// Cons:
/// - larger generated file size (2M)
/// - larger runtime static size (722K = `32*4096 + 144*4096 + 288*65`)
/// - possibly unsafe? `as_ptr() as *mut _`
/// - depends on `c_kzg`, this might not matter much
fn format_kzg_settings_large(in_path: &Path) -> String {
    const TRUSTED_SETUP_NUM_G1_POINTS: usize = c_kzg::FIELD_ELEMENTS_PER_BLOB;
    const TRUSTED_SETUP_NUM_G2_POINTS: usize = 65;

    // note: destructuring like `KzgSettings { ... }` leads to segfaults, I don't know why.
    let c_path = CString::new(in_path.to_str().unwrap()).unwrap();
    let s = c_kzg::KzgSettings::load_trusted_setup_file_inner(&c_path).unwrap();

    let max_width = s.max_width;
    let roots_of_unity = unsafe { slice::from_raw_parts(s.roots_of_unity, max_width as usize) };
    let g1_values = unsafe { slice::from_raw_parts(s.g1_values, TRUSTED_SETUP_NUM_G1_POINTS) };
    let g2_values = unsafe { slice::from_raw_parts(s.g2_values, TRUSTED_SETUP_NUM_G2_POINTS) };

    let roots_of_unity = format!("{roots_of_unity:?}").replace(' ', "");
    let g1_values = format!("{g1_values:?}").replace(' ', "");
    let g2_values = format!("{g2_values:?}").replace(' ', "");

    format!(
        r#"// @generated by build.rs from {in_path:?}, do not modify manually.

use c_kzg::{{sys::*, KzgSettings}};

pub const TRUSTED_SETUP_NUM_G1_POINTS: usize = c_kzg::FIELD_ELEMENTS_PER_BLOB;
pub const TRUSTED_SETUP_NUM_G2_POINTS: usize = 65;

pub const MAX_WIDTH: u64 = {max_width};
pub const ROOTS_OF_UNITY: &[blst_fr; MAX_WIDTH as usize] = &{roots_of_unity};
pub const G1_VALUES: &[blst_p1; TRUSTED_SETUP_NUM_G1_POINTS] = &{g1_values};
pub const G2_VALUES: &[blst_p2; TRUSTED_SETUP_NUM_G2_POINTS] = &{g2_values};

pub static KZG_SETTINGS: KzgSettings = KzgSettings {{
    max_width: MAX_WIDTH,
    roots_of_unity: ROOTS_OF_UNITY.as_ptr() as *mut _,
    g1_values: G1_VALUES.as_ptr() as *mut _,
    g2_values: G2_VALUES.as_ptr() as *mut _,
}};
"#
    )
}
*/
