use std::fs;
use std::path::Path;

const BYTES_PER_G1_POINT: usize = 48;
const BYTES_PER_G2_POINT: usize = 96;

fn main() {
    generate_kzg_settings();
}

fn generate_kzg_settings() {
    let in_path = "src/blob/trusted_setup.txt";
    let out_path = "src/blob/generated_settings.rs";

    let in_path = Path::new(in_path);
    println!("cargo:rerun-if-changed={}", in_path.display());
    assert!(in_path.exists());
    let contents = format_kzg_settings(in_path);
    fs::write(out_path, contents).unwrap();
}

fn format_kzg_settings(in_path: &Path) -> String {
    let contents = fs::read_to_string(in_path).unwrap();
    let mut lines = contents.lines();

    // load number of points
    let n_g1 = lines.next().unwrap().parse::<usize>().unwrap();
    let n_g2 = lines.next().unwrap().parse::<usize>().unwrap();

    // TODO: We can use `hex_literal` to reduce file size
    // load g1 points
    let mut g1_points = Vec::with_capacity(n_g1);
    for _ in 0..n_g1 {
        let line = lines.next().unwrap();
        let mut bytes = [0; BYTES_PER_G1_POINT];
        hex::decode_to_slice(line, &mut bytes).unwrap();
        g1_points.push(bytes);
    }

    // load g2 points
    let mut g2_points = Vec::with_capacity(n_g2);
    for _ in 0..n_g2 {
        let line = lines.next().unwrap();
        let mut bytes = [0; BYTES_PER_G2_POINT];
        hex::decode_to_slice(line, &mut bytes).unwrap();
        g2_points.push(bytes);
    }

    // remove whitespace
    let g1_points = format!("{g1_points:?}").replace(' ', "");
    let g2_points = format!("{g2_points:?}").replace(' ', "");

    format!(
        r#"// @generated by build.rs from {in_path:?}, do not modify manually.

pub const NUM_G1_POINTS: usize = {n_g1};
pub const NUM_G2_POINTS: usize = {n_g2};

pub const G1_POINTS: &[[u8; c_kzg::BYTES_PER_G1_POINT]; NUM_G1_POINTS] = &{g1_points};
pub const G2_POINTS: &[[u8; c_kzg::BYTES_PER_G2_POINT]; NUM_G2_POINTS] = &{g2_points};
"#
    )
}

// TODO: cannot dereference the KzgSettings pointers allocated in C (SIGSEGV)
/*
fn format_kzg_settings(in_path: &Path) -> String {
    const TRUSTED_SETUP_NUM_G1_POINTS: usize = c_kzg::FIELD_ELEMENTS_PER_BLOB;
    const TRUSTED_SETUP_NUM_G2_POINTS: usize = 65;

    let KzgSettings {
        max_width,
        roots_of_unity,
        g1_values,
        g2_values,
    } = dbg!(KzgSettings::load_trusted_setup_file(in_path).unwrap());

    assert_eq!(
        core::mem::size_of::<c_kzg::sys::blst_p1>(),
        c_kzg::BYTES_PER_G1_POINT * 3
    );
    assert_eq!(
        core::mem::size_of::<c_kzg::sys::blst_p2>(),
        c_kzg::BYTES_PER_G2_POINT * 3
    );

    let roots_of_unity = unsafe { slice::from_raw_parts(roots_of_unity, max_width as _) };

    let g1_values = unsafe { slice::from_raw_parts(g1_values, TRUSTED_SETUP_NUM_G1_POINTS * 3) };
    print_bytes(g1_values);
    let g2_values = unsafe { slice::from_raw_parts(g2_values, TRUSTED_SETUP_NUM_G2_POINTS * 3) };

    format!(
        r#"// @generated by build.rs from {in_path:?}, do not modify manually.

use c_kzg::{{sys::*, KzgSettings}};

pub const TRUSTED_SETUP_NUM_G1_POINTS: usize = c_kzg::FIELD_ELEMENTS_PER_BLOB;
pub const TRUSTED_SETUP_NUM_G2_POINTS: usize = 65;

pub const MAX_WIDTH: usize = {max_width};
pub static mut ROOTS_OF_UNITY: [blst_fr; MAX_WIDTH] = {roots_of_unity:?};
pub static mut G1_VALUES: [blst_p1; TRUSTED_SETUP_NUM_G1_POINTS] = {g1_values:?};
pub static mut G2_VALUES: [blst_p2; TRUSTED_SETUP_NUM_G2_POINTS] = {g2_values:?};

pub static KZG_SETTINGS: KzgSettings = KzgSettings {{
    max_width: MAX_WIDTH,
    roots_of_unity: unsafe {{ ROOTS_OF_UNITY.as_mut_ptr() }},
    g1_values: unsafe {{ G1_VALUES.as_mut_ptr() }},
    g2_values: unsafe {{ G2_VALUES.as_mut_ptr() }},
}};
"#
    )
}
*/
