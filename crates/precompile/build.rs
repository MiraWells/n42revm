#![allow(dead_code, unused_imports)]

use std::ffi::CString;
use std::fs;
use std::path::{Path, PathBuf};
use std::slice;

const BYTES_PER_G1_POINT: usize = 48;
const BYTES_PER_G2_POINT: usize = 96;

fn main() {
    generate_kzg_settings();
}

fn generate_kzg_settings() {
    // Note: we don't use `OUT_DIR` because we don't ship this build script with the crate, so all
    // used files must be in tree.
    // let out_dir = PathBuf::from(std::env::var("OUT_DIR").unwrap());
    let out_dir = Path::new("src/blob/kzg_settings");
    let out_path = out_dir.join("generated.rs");

    let in_path = Path::new("src/blob/kzg_settings/trusted_setup.txt");
    println!("cargo:rerun-if-changed={}", in_path.display());
    assert!(in_path.exists());
    let contents = format_kzg_settings_small(in_path, out_dir);
    fs::write(out_path, contents).unwrap();
}

/// Pros:
/// - smaller runtime static size (198K = `4096*48 + 65*96`)
/// - smaller generated file size (~~720K~~ same as runtime size by using `.bin` files)
/// - half the size of `trusted_setup.txt`, which would have to be included in the binary without
///   this build script
///
/// Cons:
/// - must call `load_trusted_setup` at least once
fn format_kzg_settings_small(in_path: &Path, out_dir: &Path) -> String {
    let contents = fs::read_to_string(in_path).unwrap();
    let mut lines = contents.lines();

    // load number of points
    let n_g1 = lines.next().unwrap().parse::<usize>().unwrap();
    let n_g2 = lines.next().unwrap().parse::<usize>().unwrap();

    assert_eq!(n_g2, 65);

    // TODO: We can use `hex_literal` to reduce file size
    // load g1 points
    let mut g1_points = Vec::with_capacity(n_g1);
    for _ in 0..n_g1 {
        let line = lines.next().unwrap();
        let mut bytes = [0; BYTES_PER_G1_POINT];
        hex::decode_to_slice(line, &mut bytes).unwrap();
        g1_points.push(bytes);
    }

    // load g2 points
    let mut g2_points = Vec::with_capacity(n_g2);
    for _ in 0..n_g2 {
        let line = lines.next().unwrap();
        let mut bytes = [0; BYTES_PER_G2_POINT];
        hex::decode_to_slice(line, &mut bytes).unwrap();
        g2_points.push(bytes);
    }

    assert!(lines.next().is_none());

    fs::write(out_dir.join("g1_points.bin"), into_flattened(g1_points)).unwrap();
    fs::write(out_dir.join("g2_points.bin"), into_flattened(g2_points)).unwrap();

    format!(
        r#"// @generated by build.rs from {in_path:?}, do not modify manually.

pub use c_kzg::{{BYTES_PER_G1_POINT, BYTES_PER_G2_POINT}};

// Ensure that the build script constants are synced with the C bindings ones.
const _: [(); BYTES_PER_G1_POINT] = [(); {BYTES_PER_G1_POINT}];
const _: [(); BYTES_PER_G2_POINT] = [(); {BYTES_PER_G2_POINT}];

pub const NUM_G1_POINTS: usize = {n_g1};
pub const NUM_G2_POINTS: usize = {n_g2};

type G1Points = [[u8; BYTES_PER_G1_POINT]; NUM_G1_POINTS]; 
type G2Points = [[u8; BYTES_PER_G2_POINT]; NUM_G2_POINTS]; 

pub const G1_POINTS: &G1Points = {{
    const BYTES: &[u8] = include_bytes!("./g1_points.bin");
    assert!(BYTES.len() == core::mem::size_of::<G1Points>());
    unsafe {{ &*BYTES.as_ptr().cast::<G1Points>() }}
}};
pub const G2_POINTS: &G2Points = {{
    const BYTES: &[u8] = include_bytes!("./g2_points.bin");
    assert!(BYTES.len() == core::mem::size_of::<G2Points>());
    unsafe {{ &*BYTES.as_ptr().cast::<G2Points>() }}
}};
"#
    )
}

/*
/// Pros:
/// - no need to call `load_trusted_setup` at runtime
///
/// Cons:
/// - larger runtime static size (722K = `4096*32 + 4096*144 + 65*288`)
/// - larger generated file size (2M)
/// - possibly unsafe? `as_ptr() as *mut _`
/// - depends on `c_kzg`; this might not matter much
fn format_kzg_settings_large(in_path: &Path) -> String {
    const TRUSTED_SETUP_NUM_G1_POINTS: usize = c_kzg::FIELD_ELEMENTS_PER_BLOB;
    const TRUSTED_SETUP_NUM_G2_POINTS: usize = 65;

    // note: destructuring like `KzgSettings { ... }` leads to segfaults, I don't know why.
    let c_path = CString::new(in_path.to_str().unwrap()).unwrap();
    let s = c_kzg::KzgSettings::load_trusted_setup_file_inner(&c_path).unwrap();

    let max_width = s.max_width;
    let roots_of_unity = unsafe { slice::from_raw_parts(s.roots_of_unity, max_width as usize) };
    let g1_values = unsafe { slice::from_raw_parts(s.g1_values, TRUSTED_SETUP_NUM_G1_POINTS) };
    let g2_values = unsafe { slice::from_raw_parts(s.g2_values, TRUSTED_SETUP_NUM_G2_POINTS) };

    let roots_of_unity = format!("{roots_of_unity:?}").replace(' ', "");
    let g1_values = format!("{g1_values:?}").replace(' ', "");
    let g2_values = format!("{g2_values:?}").replace(' ', "");

    format!(
        r#"// @generated by build.rs from {in_path:?}, do not modify manually.

use c_kzg::{{sys::*, KzgSettings}};

pub const TRUSTED_SETUP_NUM_G1_POINTS: usize = c_kzg::FIELD_ELEMENTS_PER_BLOB;
pub const TRUSTED_SETUP_NUM_G2_POINTS: usize = 65;

pub const MAX_WIDTH: u64 = {max_width};
pub const ROOTS_OF_UNITY: &[blst_fr; MAX_WIDTH as usize] = &{roots_of_unity};
pub const G1_VALUES: &[blst_p1; TRUSTED_SETUP_NUM_G1_POINTS] = &{g1_values};
pub const G2_VALUES: &[blst_p2; TRUSTED_SETUP_NUM_G2_POINTS] = &{g2_values};

pub static KZG_SETTINGS: KzgSettings = KzgSettings {{
    max_width: MAX_WIDTH,
    roots_of_unity: ROOTS_OF_UNITY.as_ptr() as *mut _,
    g1_values: G1_VALUES.as_ptr() as *mut _,
    g2_values: G2_VALUES.as_ptr() as *mut _,
}};
"#
    )
}
*/

/// [`Vec::into_flattened`].
#[inline]
fn into_flattened<T, const N: usize>(vec: Vec<[T; N]>) -> Vec<T> {
    let (ptr, len, cap) = into_raw_parts(vec);
    let (new_len, new_cap) = if core::mem::size_of::<T>() == 0 {
        (len.checked_mul(N).expect("vec len overflow"), usize::MAX)
    } else {
        // SAFETY:
        // - `cap * N` cannot overflow because the allocation is already in
        // the address space.
        // - Each `[T; N]` has `N` valid elements, so there are `len * N`
        // valid elements in the allocation.
        unsafe {
            (
                len.checked_mul(N).unwrap_unchecked(),
                cap.checked_mul(N).unwrap_unchecked(),
            )
        }
    };
    // SAFETY:
    // - `ptr` was allocated by `self`
    // - `ptr` is well-aligned because `[T; N]` has the same alignment as `T`.
    // - `new_cap` refers to the same sized allocation as `cap` because
    // `new_cap * size_of::<T>()` == `cap * size_of::<[T; N]>()`
    // - `len` <= `cap`, so `len * N` <= `cap * N`.
    unsafe { Vec::from_raw_parts(ptr.cast(), new_len, new_cap) }
}

/// [`Vec::into_raw_parts`]
#[inline(always)]
fn into_raw_parts<T>(vec: Vec<T>) -> (*mut T, usize, usize) {
    let mut me = core::mem::ManuallyDrop::new(vec);
    (me.as_mut_ptr(), me.len(), me.capacity())
}
